fn + q

# 常用命令

## Sql

### 登录命令等..

* mysql -u root -p

* SHOW DATABASES;

* SHOW TABLES;

* CREATE DATABASE spring_cache_demo;
* desc tables; 显示表的字段

* DROP DATABASE IF EXISTS names;d

```mysql
内连接
SELECT column1, column2, ...
FROM table1
INNER JOIN table2 ON table1.column_name = table2.column_name;

左外连接
SELECT column1, column2, ...
FROM table1
LEFT JOIN table2 ON table1.column_name = table2.column_name;

右外连接
SELECT column1, column2, ...
FROM table1
RIGHT JOIN table2 ON table1.column_name = table2.column_name;
```



## Git命令

* 把当前分支改名为main

```
git branch -M main  
```

* 配置公钥 不断回车，然后密钥在C:\Users\zhoujia\\.ssh\id_rsa.pub( ~/.ssh/id_rsa.pub)里面

```java
ssh-keygen -t rsa
```

* 添加远程仓库地址

```
git remote add origin http.xxx
```

* 推送到仓库
*  git push origin master:master  
*  git push [-f] [--set-upstream] 远端名称  本地分支名:远端分支名
* -f代表强制推送 
* git branch -vv **查看分支的对应关系**
*  git push --set-upstream origin master:master **绑定分支关系**

```
git push origin main
```

* **git-log的别名 使得页面更清晰**

```java
alias git-log='git log --pretty=oneline --all --graph --abbrev-commit'
```

* **回退**

```java
git reset --hard commitId
```

* **回退之后再想回去查看回退之前那个id**

```java
git reflog
```

* 创建分支

```java
git branch dev
```

* **创建并切换到分支**	

```java
git checkout -b dev
```

* **合并分支**

```java
git merge dev
```

* **删除分支**

```java
git branch -d dev
```

* 强制删除分支(这个分支上有代码没合并才需要强行删除)

```java
git branch -D dev
```

* 抓取 ,指把远程origin/xx分支抓取下来，但是需要你手动合并

```java
git fetch
```

* 拉取，抓取并合并(只拉同名字分支)

```java
git pull
```



## Redis

``````
redis-server.exe redis.windows.conf
redis-cli.exe -h localhost -p 6379 -a zhoujia.123
``````

mysql :root zhoujia.123

## Linux

### which和 find命令

* `find  / -name  “123”` 表示在根目录下查找文件名为123的文件
* `find / -name +1G` 查找大于1G的文件

* `which touch `查找名字为touch的可执行文件

### grep-wc-管道符

`wc -c -m -l -w 文件路径`是一个用于统计文件中行数、单词数和字节数的命令。

* -c bytes数量 -m 字符数量 -l 行数 -w 单词数

* grep "关键字" 文件名

* `-n`：显示匹配行的行号。

  `-i`：忽略大小写。

  `-v`：反向匹配（显示不包含关键字的行）。

  `-r`：递归地查找目录中的所有文件。

  `-l`：只显示包含关键字的文件名。

  

### echo和tail

* `echo 'pwd'`把pwd当作命令执行
* `echo 'pwd' >> test.txt` 把当前路径追加到test中，`>>`表示追加,`>`表示覆盖写

`tail -f -num 文件路径`

* -f 表示持续追踪，num表示打印倒数几行

### Vim

yy 复制 u撤销操作 p粘贴 dd删除一行

o键在光标下一行进入输入模式

/查找 n下一个 N上一个

gg跳到首行 G跳到末尾

----

底线命令模式

* q!表示强制退出不保存 set nu 显示行号 set paste 粘贴模式

### Root用户

su - root 切换到root 

exit切换到上一个用户 或者 ctrl + d 

sudo获得root权限

* visudo打开文件 zhoujia ALL=(ALL)	NOPASSWD:ALL

# 面经

mysql索引底层为什么是b+树不是红黑树
讲一下红黑树的数据结构
mysql磁盘IO效率为什么低
sql优化有哪些
联合索引创建的顺序怎么确定
索引失效情景
mysql普通索引跟主键索引在查找数据的区别
mysql的ACID基于哪些，怎么实现的
mysql怎么实现主从同步
mysql的从节点宕机了怎么恢复数据
mysql的从节点使用二进制文件同步和执行SQL哪个同步数据更快，为什么
mysql跟redis怎么确定要使用哪种数据库
redis的网络协议
项目有使用redis主从复制吗
Redis主从同步的工作原理
缓存穿透，击穿雪崩以及解决方案
解决缓存击穿除了redis分布式锁还有什么方案，如果不加锁怎么解决（讲了逻辑过期，他说用定时任务，专门开启一个线程去执行监听）
建立连接成功后，服务端怎么确认客户端发送的消息没有被篡改过，恶意篡改怎么办（说了可以对数据内容用hash运算判断，他说还有呢）
对称加密与非对称加密
了解密码学吗
hashmap的数据结构
hashmap怎么存储亿级数据
如果初始化大容量存储的话怎么解决扩容效率低的问题 （说了渐进式哈希）
讲一下渐进式哈希怎么实现的
那并发修改时，大容量的hashmap怎么保证线程安全（说了加分段锁，感觉他不是很满意）
又说了可以先把大容量数据做分桶再放到hashmap，那数据分桶具体怎么划分，根据什么来划分
tcp四次挥手具体
讲一下你知道的非阻塞IO模型
https跟http有什么区别
讲一下怎么判断你访问的网站就是腾讯的官网
CA相关
讲一下数字证书怎么生成
数字签名怎么生成
线程跟协程区别
一个线程可以有多少个协程，怎么查看
在mysql默认隔离级别下，两个事务同时修改一个数据，会发生什么，怎么解决（说了修改数据库隔离级别为串行化，他说换一种方式，这种性能太低，我又说了行锁跟间隙锁）

算法：二选一 + 二选一（刚好做出来两道）：1.构建大顶堆，pop操作实现

2. 手写一个哈希表，实现增删改查接口，使用拉链法解决哈希冲突，不可以使用类库
3. 还没看题目
4. 螺旋矩阵

## Java基础

### ==和equals

对于 `String` 类型，`==` 运算符比较的是两个 `String` 对象的引用地址是否相同，也就是判断它们是否是内存中的同一个对象实例。而 `equals()` 方法（`String` 类重写了 `Object` 类的 `equals()` 方法）比较的是两个 `String` 对象的字符序列是否完全相同，即它们的内容是否相等。

### throw和throws的区别

* **throw:**用在**方法体内部**，用来**显式地抛出一个异常对象**。
* **throws :**声明一个方法可能抛出的异常类型，告知调用者需要处理这些异常,调用这个方法的时候idea会强制要求你try catch包住 。

### ***重写equals为什么要重写hashcode？

JDK的约定就是如果 `equals` 方法返回 `true`，则 `hashCode` 必须相等。不重写会出现hashset存入异常，两个equals的类，会被存到两个位置，没有去重。本身就不合逻辑

### ***Object类有哪些方法？

`equals(),hashcode(),toString,getClass(),clone(),wait(),notify()`

### **int i =100； Integer j= new Integer (1000); 判断j==i的结果？ 并解释为什么

true,j会发生自动拆箱变成int类型 结果就是相等

### *？如何理解 Java 的跨平台性

### ***Java为什么要有Integer？

### *说一下 integer的缓存

### *？泛型为什么只能存对象

类型擦除是 Java 编译器在**编译阶段**将泛型参数替换为 **原始类型（Raw Type）** 并移除泛型信息的过程。

在编译后，Java **会擦除泛型 `T`，并用 `Object` 代替**：

```java
class Box {
    private Object value;  // 泛型 T 被擦除为 Object

    public void setValue(Object value) {  // 泛型方法也被擦除
        this.value = value;
    }

    public Object getValue() {  // 泛型返回类型被擦除
        return value;
    }
}

```
### **怎么理解面向对象？简单说说封装继承多态

**继承** 

* **代码复用**
* **可维护性 :** 当需要修改或修复父类中的某个通用功能时，只需修改父类代码即可。
* **可扩展性 (Extensibility):** 可以基于现有的父类轻松创建新的子类，添加或修改特定的功能。

**多态:**多态允许你使用父类或接口类型的引用来指向子类或实现类的对象

* 接口规范
* 多态使得代码不依赖于具体的子类实现，而是依赖于抽象的父类或接口。

* **方法重写（Override）**：子类重写父类的方法，实现不同的功能。

* **方法重载（Overload）**：同一类中的方法名称相同，但参数不同。

**为什么需要多态？**

- **提高代码的扩展性**：可以在不修改原代码的情况下，添加新的行为。
- **让代码更加灵活**：父类引用可以指向不同的子类对象，代码复用性强。

###  ***?面向对象的设计原则

**依赖倒置原则**:简单来说，就是 要依赖抽象（接口），而不是具体的实现类
**开放封闭原则**：**可以扩展功能（Open for extension）** ，✅**但不能修改已有代码（Closed for modification）** ❌。

**单一职责原则**：即一个类应该只负责一项职责

比如说某个类的方法依赖其他类的方法，最好在这个类中只定义类的接口就行，实际用的时候再传，而不是定义的时候就写死了某个实例。

### ***Java抽象类和接口的区别

* 单继承和多继承
* 可以有普通变量和 `static` 变量，接口只能有 `public static final` 变量
* 可以有**普通方法**和**抽象方法**，Java 8+ 可以有 `default` 方法和 `static` 方法，其他方法都是**抽象的**，default方法子类可以直接用或者重写
* 适用于**有相同属性或部分实现**的类，适用于**定义行为规范**

### **抽象类和普通类区别？

* 抽象类可以有抽象方法和普通方法，接口只能有默认方法，抽象方法，静态方法
* 抽象类是单继承，接口多继承，抽象类可以用来代码复用，接口主要是定义接口规范

### *什么是泛型？

### **java创建对象有哪些方式

* 反射创建对象

```java
    Class<?> clazz = MyClass.class;
    MyClass obj = (MyClass) clazz.newInstance();
```



### **反射在你平时写代码应用场景有哪些?

###  Java 8 你知道有什么新特性？

* **Lambda 表达式**：`(a, b) -> a + b` 代替匿名类实现接口

* 函数式接口是只包含一个抽象方法的接口。

* 接口可定义**默认实现和静态方法**，增强扩展性

* **Stream API**:

* ```java
  List<String> originalList = Arrays.asList("apple", "fig", "banana", "kiwi");
  List<String> filteredList = originalList.stream()
                          .filter(s -> s.length() > 3)
                          .collect(Collectors.toList());
  ```

### ？？？？深拷贝和浅拷贝

* 浅拷贝拷贝一个对象，会复制出一个新的对象来，但是这个对象里面的引用类型依然指向原来的那个对象里面的引用。

* 深拷贝对象的引用类型中则指向一个新的对象。

### ？？？try里面有return的话，执行过程是怎么样的

* 先把return的值保存起来，再去执行finally，假如finally里也有return 就会return finally的值。

fans

### 数据结构了解哪些

* 数组、链表、栈、队列，哈希表
* 二叉搜索树，堆、b+树、

## Spring

### ***SpringBoot比Spring优化在哪里

* 不需要写xml配置bean，只需要配置类配置bean就行

* SpringBoot 提供自动配置，不用**手动配置组件**，只需**application.yml**：
* SpringBoot Starter **依赖管理**更简单，不然自己配**会报错**

### ***写过SpringBoot starter吗?

1.创建新的maven项目，添加一些依赖

2.spring.factories中添加一个自动配置类

3.创建自动配置类，添加@EnableConfigurationProperties用于启用你定义的配置属性类。

4.添加配置属性类绑定配置文件中的属性。

5.添加一个service类，然后在自动配置类中装配为bean并返回service实例

### ***Spring事务失效

* 发生了@RuntimeException之外的异常会失效（除非你指定了**处理所有exception**）
* 自己捕获异常，没有抛出
* 非public函数就会失效
* 数据库引擎不支持事务，例如 MySQL 的 MyISAM 引擎不支持事务。

### ***Bean的生命周期

**1.实例化**

**2.依赖注入，属性赋值**

3Bean实现Aware接口回调：BeanNameAware，BeanClassLoaderAware ApplicationContextAware 等。它提供了一种**"让 Bean 感知 Spring 容器自身信息"**的机制。如**Bean 的名称**，**Bean的类加载器，Bean的容器**

**4.初始化前 执行BeanPostProcessor before方法**

**5.初始化方法**

6**.初始化后 执行BeanPostProcessor after方法**

7**.使用bean**

8.如果 Bean 实现了 DisposableBean 接口，则会执行 destroy() 方法。

**9.销毁bean**，执行destroy方法



### ***Spring注解

* **@Resource**和**@Autowired**：**@Resource**按照变量名找，找不到再按照类型，**@Autowired**按照类型找

* **@Import** 把一个类注册成一个 Bean（即使它没有 `@Component`）
* **@Bean和@Configuration**：@Bean这个方法返回的对象是一个 Bean，要放进 Spring 容器中，@Configuration保证 `@Bean` 方法之间的调用是通过 Spring 容器执行而不是new一个出来。
* **@ComponentScan** 扫描这个包下的bean对象
* **@EnableAutoConfiguration** 包含
  * **@Import(AutoConfigurationImportSelector.class)**，这个注解把**所有依赖下的spring.factories文件**里面的自动配置类的bean注入到容器中
* **@ConfigurationProperties**：用于定义一个 **Java Bean**，让 Spring **自动将 `application.properties` 或 `application.yml` **里的**配置绑定到**这个 Bean 的**属性上**。
* **@EnableConfigurationProperties**：如果 `@ConfigurationProperties` 的类没有 `@Component`（**例如 Starter 自动配置中**），就需要 `@EnableConfigurationProperties` **来显式启用它。**

### ***自动配置原理

主要是靠这个注解

**@EnableAutoConfiguration** 包含

* **@Import(AutoConfigurationImportSelector.class)**，这个注解把**所有依赖下的spring.factories文件**里面的自动配置类的bean注入到容器中

### ？？？？？Mybatis如何实现分页？

### ？？？依赖注入@Autowired 和 @Resource 的区别

* **`@Resource`**：默认按**名称注入**，若找不到则按**类型注入**。存在多个实现时，可以通过`name`属性显式指定要注入的Bean名称。jdk原生注解
* **`@Autowired`**：默认按**类型注入**，若有多个同类型的Bean时，需要结合`@Qualifier`或`@Primary`注解来明确指定注入的Bean。spring衍生出的注解

### ？？？spring的ioc（控制反转）和aop如何理解

* **ioc**将创建对象的权力给了**容器**，降低了耦合度，想使用对象的时候使用依赖注入就行。
* 降低耦合度，假如要修改成不同的实现，只需要@Qualifier注解就行
* **AOP**：主要是用来增强一个方法，一些跟业务逻辑无关的代码可以跟方法解耦，通过动态代理来实现，降低了业务代码和无关代码的耦合性，维护性比较好。

### ？？？循环依赖spring如何解决的，spring能解决所有循环依赖吗，如果遇到解决不了的怎么办

* 三级缓存解决循环依赖，一级缓存存储完整的创建好的bean，二级缓存还没初始化完的bean对象，三级缓存 存的是对象工厂（专门用来生成代理对象），主要是解决代理对象的循环依赖
* 有一些循环依赖需要手动解决，构造器注入会解决不了，使用懒加载就行。是因为**构造器注入在 Bean 实例化阶段就需要所有的依赖都准备好**，这个时候没办法放入缓存就已经产生了循环依赖。

### ？？？Mybatis中的${}和#{}的区别

### ？？？Spring管理事务的方式有哪些？

### ？？？Spring事务中哪些事务传播行为？

### ？？？IOC是怎么实现的

* 工厂 + 反射

### ？？？依赖注入的方式有

* 构造器注入

* Setter 方法注入
* @Resource这种

### ？？？自动装配原理

## SpringCloud

### **有哪些组件

* **注册中心（Nacos）**：所有微服务向注册中心 **注册自身** 的信息，其他微服务调用时从**注册中心获取地址**。此外还有**负载均衡和监察健康情况**的作用，不可用服务直接下线。
* **网关Gateway**：
* **远程调用Feign**：
* **服务容错与熔断Sentinel**：
  * **服务雪崩**：一个微服务**宕机**，导致一个**链路的服务都宕机**。解决：**Hystix熔断降级**。
  * **降级**就是如果 **服务超时**，返回一个默认的值，而不是直接报错；
  * **熔断** ：当下游服务持续失败或响应超时时，短时间内自动拒绝请求；
  * 熔断器通常有 **三种状态**：**关闭（Closed）**：正常状态，请求可以正常调用。**半开（Half-Open）**：短时间内允许部分流量测试服务是否恢复。**打开（Open）**：如果失败率超过阈值，熔断器打开，直接返回错误，防止下游服务过载。
* **负载均衡Ribbon**：负载均衡策略：轮询、按照权重去选择服务器（响应时间越长，权重越小）、随机、选择较空闲的去连接。

### 限流

* **Nginx，漏桶算法**：请求先进入漏桶，桶内按照 固定速率 流出，超出桶容量的请求被丢弃。绝对固定速率
* **网关，令牌桶算法-RequestRateLimiter**：令牌 按固定速率 生成，请求需要获取令牌才能通过。适用于限流后不丢弃请求的场景（可以排队等待令牌）。会有波动
* **Tomcat：**设置最大连接数****

## Mysql

### Left join ,right join 和inner join的区别

### String对象为什么是不可变的，如何理解。

### 为什么b+树的高度决定了磁盘的IO次数?

节点是在磁盘上的，访问路径上的节点时都需要进行一次磁盘IO操作，那么跳转到下一个节点又要用一次io操作。

### 乐观锁和悲观锁的业务场景举例？

乐观锁：**读多写少**，并发量大但冲突少的场景，比如 **商品库存扣减、用户余额扣减、积分更新等**。如果冲突多，失败率高，可能导致大量重试影响性能。

悲观锁：**写多读少**，并发冲突严重的场景，比如 **银行转账、订单支付、库存锁定等**。

### MVCC

MVCC 是通过数据的多版本存储和快照视图来实现的。

数据的多版本是通过隐藏列和 Undo Log 来实现的。每条记录会存储事务 ID 和指向旧版本的指针，事务启动后，第一次查询就固定了这个视图，视图确保事务读取的数据保持一致。然后事务会根据自身的快照去undolog中找到正确的数据版本。

### ？？？如果让构建索引，你会如何考虑？

### ***ACID如何保证

* **原子性: 保证事务中的所有操作要么全部完成，要么全部不完成。**Undo Log（回滚日志）
* **一致性**： 
* **持久性**：保证一旦事务提交成功，其所做的修改就会永久保存在数据库中，即使系统发生崩溃也不会丢失。redolog崩溃恢复
* **隔离性：**保证并发执行的多个事务相互隔离，一个事务的执行不应影响其他事务的执行。通过mvcc+锁机制来保证

### **mysql引擎

* MyISAM：不支持事务，回滚不了，但是执行速度比innodb快；执行写入操作（`INSERT`、`UPDATE`、`DELETE`）时，会锁定整个表；只有非聚簇索引 ，语句全都需要回表。没有持久化机制。
* memory: 将所有数据存在内存中，读写性能比较快；没有持久化机制；没有事务机制；锁最小粒度只有表级锁；支持Hash索引和B树索引；
* innodb

### mysql磁盘IO效率为什么低

### ***如何定位慢查询

* 开启慢查询日志（/etc/my.cnf）

### **索引创建考虑什么

* where，order by，group by的语句考虑建立索引
* **区分度较高**的字段建立索引，区分度指**重复度比较小**
* 如果是字符串建立索引，如果字符串长，考虑建立前缀索引，选择区分度高的前缀为索引长度
*  在多个字段都要创建索引的情况下，**联合索引优于单值索引**，把最频繁的条件放到最左侧，联合索引可以使用**覆盖索引**，**避免回表**。联合索引优于单值索引是因为，单个表索引数量也不要太多，因为维护索引也要一定的时间成本。
* 不建议用无序的值作为索引，因为插入索引时候很有可能导致页分裂。

### ***sql语句优化

* 避免使用select *，可能要回表。
* 使用union all 代替union，union多一次过滤，效率低
* 不要在where后进行表达式操作。
* 能用inner join就不要用left 或者right join，因为inner join会优化，可以减少对数据库的连接
* join的表不宜过多，最好不超过三个，因为增加一个join是以乘积的形式增加扫描的行数。

### ***索引失效情景

* 

### ***mysql怎么实现主从同步

### ***mysql的从节点宕机了怎么恢复数据

### mysql的锁分类

* 全局锁 ，只准读不准写，备份时候用
* 表级锁
  * 表锁，独占写锁和共享读锁
  * 元数据锁，修改表的语句会上元数据写锁，增删改查就会上元数据读锁。
  * 意向锁：排他行锁会给表一个排他意向锁，共享行锁会上一个共享意向锁。主要是想对表上行锁（独占写锁和共享读锁）的时候可以直接知道，免得一行行去扫描。
* 行锁

### mysql死锁情况

### 如何防止sql注入

* 使用mybatis中的#号而不是$符号

* $符号会直接把参数拼接到sql语句上
* #{}会使用？作为占位符 如ELECT * FROM users WHERE username = ? ，想要注入 OR ‘1’ = 1 ，并不行，数据库只会认为？的地方是一个参数而已，不会当作sql语句

## Java集合

### ***常⻅的集合有哪些？

**ArrayList**

* 底层是动态数组

* `ArrayList` **可以使用任意单列（非 Map 类型）集合初始化**
* **扩容逻辑**：当数组满了，扩容**1.5倍**，初始容量是**0**，第一次添加时就**扩容到10.**
* Array.asList(数组)可以**转成List**，**List转数组**：list.toArray（new int[list.size()]）

**LinkedList和ArrayList的区别**

* linkedlist是双向链表实现的，ArrayList底层是动态数组
* 都不是线程安全的

**CopyOnWriteArrayList**、**TreeSet**（自动排序的集合）、**LinkedHashMap**（保留了元素插入的顺序）、**PriorityQueue**（根据元素的优先级来获取元素）



###  Arraylist和LinkedList的区别？

### 为什么ArrayList不是线程安全的？

### HashMap的原理

### 为什么HashMap要用红黑树而不是平衡二叉树？

### HashMap的扩容机制

### 列举HashMap在多线程出现的问题？

###  如何对map进行快速遍历？

### Hashmap和Hashtable有什么不一样的？

### CopyOnWriteArrList 是怎么实现安全的

当需要修改 CopyOnWriteArrayList 中的元素时，它不会直接在原数组上进行修改，而是会进行以下步骤：

1. **复制数组 (Copy):** 创建一个原数组的副本（一个新的数组）。
2. **修改副本 (Write):** 在这个新的副本数组上执行修改操作（例如，添加、删除、更新元素）。
3. **替换引用 (Replace):** 将内部指向旧数组的引用更新为指向这个新的副本数组。

由于所有修改操作都是在副本上进行的，并且在修改完成之前，读操作仍然是在旧数组上进行的，因此**读操作和写操作不会互相干扰**。

## Redis

### 缓存淘汰和过期删除

### Redis底层的数据结构

###  Zset 底层是怎么实现的？

### 哈希表是怎么扩容的？

### 哈希表扩容的时候，有读请求怎么查？

### Redis为什么快？

### Redis为什么使用跳表而不是用B+树?反之呢？

* **在数据库中，磁盘 IO 是关键瓶颈，跳表的指针太多，导致访问局部性差，不适合磁盘存储**。
* 跳表实现简单，插入/删除时不会有 B+ 树的节点拆分/合并问题。

### redis中hash冲突是怎么解决的

链式哈希，当多个键映射到相同的槽位时，Redis 会将它们存储为链表，这样每个槽位都可以存储多个键值对。

###  Redis为什么快？

1.**都在内存中完成**。2.单线程模型可以**避免了多线程之间的竞争**，省去了上下文切换3.Redis 采用了 **I/O 多路复用机制**

* I/O 多路复用是指利用单个线程来同时监听多个Socket，并在某个Socket可读或者可写时得到通知。目前的I/0多路复用都是采用的epoll模式实现。它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket是否就绪，提升了性能。

### 大key问题

* 阻塞其他操作。某些对大Key的操作可能会导致Redis实例阻塞。

### Redis集群有什么作用

* 解决了海量数据存储的问题
* 通过哈希槽分片实现了高并发的读和写
* 请求可以转发到正确的节点上

### 集群分片是怎么存储和读取的？

### Redis分布式锁的底层原理

### AOF和RDB

### 解决缓存击穿除了redis分布式锁还有什么方案

## JUC

### ？？？JUC包知道哪些？怎么使用？

### StringBuffer怎么实现线程安全的

### ***线程和进程的区别

* 进程是**操作系统分配资源**的单位，每个进程拥有**独立的内存空间**；而线程是进程中的**执行单元**，线程之间**共享进程资源**

* 进程切换需要上下文切换，开销比线程大（仍有上下文切换开销）；

### Java线程的状态有哪些

### ***导致并发安全的根本问题，怎么保证多线程安全？

* 根本问题，可见性，有序性，原子性

### 不同的线程之间如何通信？

* wait()、notify()、notifyAll()
* `RecurrentLock` 和 `newCondition` 方法。这个比wait，notify更加精细。可以显式的唤醒某个线程
* `CountDownLatch`

### sleep 和 wait的区别是什么？

### *synchronized锁静态方法和普通方法区别

* 普通方法锁的是当前实例对象，静态方法锁的是类对象

### ***synchronized原理？

它依赖于 JVM 的监视器锁（Monitor）机制，当使用syn（obj）加锁时，锁对象的对象头里面的mark word会标识锁的不同状态，锁有一个升级的过程。

* 偏向锁是为了优化单线程访问的场景。当对象没有被任何线程锁定时，JVM 会自动将锁偏向第一个获取锁的线程。这样，后续同一线程重复获取锁时不需要进行任何竞争或加锁操作。**Mark Word** 中存储的是持有锁的线程 ID，表示该对象的锁被该线程偏向。
* CAS的逻辑就是，尝试把线程id替换为自己的线程id，如果失败了说明有线程在竞争，锁升级
* 当有多个线程竞争锁时，**偏向锁**会被升级为**轻量级锁**。轻量级锁会在对象头的 **Mark Word** 中存储一个指向**锁记录的指针（存储了线程的信息）**，其他线程会自旋尝试获取锁即**CAS**的修改Mark word中的**标志位（要从无锁01改成有锁00），成功了就把当前线程的锁记录放进去**，直到自旋到获取到这个锁。
* 当锁竞争激烈时，轻量级锁会升级为 **重量级锁**，此时 `Mark Word` 会记录指向 **Monitor** 对象的地址。**Monitor** 中包含一个 **owner**，它表示当前持有锁的线程，同时还有一个 **阻塞队列**，用于存储那些尝试获取锁但被阻塞的线程。解锁时，持有锁的线程会释放锁并唤醒阻塞队列中的线程，允许它们去竞争锁。





### synchronized和reentrantlock及其应用场景有什么区别？

* **可中断性**:可以使用 `tryLock() 和 lockInterruptibly() 方法能够响应中`
* **设置超时时间**: `tryLock(long time, TimeUnit unit)` 方法来设置超时时间
* **公平锁和非公平锁: `new ReentrantLock(true)` 来创建**
* **实现不同：**synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。

### synchronized能够修饰什么，各有什么区别

* 普通方法：锁住调用类的实例对象
* 静态方法：锁住class对象
* 同步代码块

### JMM?

### CAS 有什么缺点？

### CAS原理

而是直接通过 JVM 调用了操作系统底层的**CPU 提供的原子指令**，一次实现比较和交换两个动作。`Unsafe` 类提供了一个桥梁

### 悲观锁和乐观锁的区别？

### voliatle关键字有什么作用？

### ***AQS的原理

**一个原子变量 `state`** 来表示锁的状态（0 代表空闲，大于 0 代表锁被占用）。

**CAS（Compare-And-Swap）操作** 来保证 `state` 的原子性修改。

**一个 FIFO 线程等待队列** 来管理被阻塞的线程。

基本思想就是维护一个原子state和一个owner，一个线程获取锁的逻辑就是尝试cas的修改这个state为1，如果修改成功，就把owner改成当前线程。如果没获取到锁，把线程放到队列尾部，加进去之后自旋一次获取锁（这是为了防止加入之后锁已经被释放了），没获取到锁就阻塞等待唤醒。解锁逻辑就是，把state修改为0，唤醒队列里的的线程。

### 指令重排序的原理是什么？

### 什么情况会产生死锁问题？

**互斥**（Mutual Exclusion）：

- 资源一次只能被一个线程占用。

**占有且等待**（Hold and Wait）：

- 线程1持有A资源的同时，还在等待B资源。线程2持有B资源，等待A资源。

**不可剥夺**（No Preemption）：

- 资源不能被强制回收，必须由持有者释放。

**循环等待**（Circular Wait）：

- 线程之间形成资源**环形依赖**（A 等 B，B 等 A）

### ***ConcurrentHashMap？

volatile + CAS 或者 synchronized 实现

* `Node.val` 被 **`volatile` 修饰**，保证保证写入后对其他线程可见。计算hashcode之后，如果该索引位置是空的，使用 CAS 插入，失败的线程会重试。
* 如果桶位置不为空，就利用synchronized锁住该位置链表的头节点，去链表找那个key，**不会锁整个 `ConcurrentHashMap`**，并发度较高。

### Runnable和Callable有什么区别

✅ **使用 `Runnable`**

- 不需要返回值
- 任务是 I/O 操作、日志记录、数据处理等

✅ **使用 `Callable`**

- 需要返回值（如计算任务）
- 需要处理受检异常（如数据库操作、文件读取）
- 需要与 `Future` 结合，异步获取结果

### ***？为什么要用线程池

* 复用线程，避免频繁创建和销毁线程的开销
* 限制最大线程数，避免系统过载

### *** 线程池的参数是哪些，怎么选择参数，线程池原理是什么？

* **corePoolSize**：核心线程数。**CPU密集型：CPU核数 + 1**（电商秒杀是短暂的 CPU 消耗，大量的io等待（数据库缓存读写）），**IO密集型（）:CPU核数 x 2**
* **maximumPoolSize：**最大线程数 = 核心 + 救急线程数 
* **keepAliveTime**：救济线程的生存实时间
* **workQueue**：线程阻塞队列，没有空闲核心线程时，任务进入队列等待
* **threadFactory**：定制线程的名字
* **handler**：当所有线程都忙，阻塞队列也满了，考虑拒绝
* 任务来了，线程池优先分配空闲核心线程；若无空闲核心线程，则尝试加入任务队列；队列满时，若未达最大线程数则创建非核心线程；超出最大线程数和队列容量则执行拒绝策略。

### ***有哪些拒绝策略

* CallerRunsPolicy，使用线程池的调用者所在的线程去执行被拒绝的任务，除非线程池被停止或者线程池的任务队列已有空缺。
* AbortPolicy，直接抛出一个任务被线程池拒绝的异常。
* DiscardPolicy，不做任何处理，静默拒绝提交的任务。
* DiscardOldestPolicy，抛弃最老的任务，然后执行该任务。

### **线程池种类有哪些？

* **FixedThreadPool：**拥有固定数量的核心线程，没有救急线程，阻塞队列无限大，容易导致oom。
* **CachedThreadPool：** 核心线程数为 0，最大线程数无限制，没有阻塞队列，空闲线程会被回收。容易创建很多线程导致oom。
* **SingleThreadExecutor：** 只有一个核心线程，保证所有任务按顺序执行，阻塞队列无限大。适用于需要串行执行任务的场景。容易导致oom
* **ScheduledThreadPool**: 支持定时或周期性执行任务。适用于需要调度任务的场景。

### **线程池有哪些阻塞队列

* **ArrayBlockingQueue**（有界，FIFO）➡ **适合任务量可预测**，防止 OOM。一把锁锁住整个数组，入队和出队操作是互斥的。
* **LinkedBlockingQueue**（默认无界（可以设置有界），FIFO）➡ **吞吐量高，但可能导致 OOM**。两把锁 锁住链表头和尾，出队入队操作不互斥。
* **SynchronousQueue**（不存储任务，直接交给线程执行）➡ **适用于高并发、任务执行迅速**。
* **DelayQueue**（任务延迟执行）➡ **适用于定时任务、缓存超时清理**。

### 线程池中的线程执行遇到异常和处理？任务丢失怎么解决？

* 任务内部遇到异常，用try-catch捕捉打印异常就可以了
* 如何程序崩溃可能就会丢失任务，可以考虑用mq来存储消息，或者直接持久化到数据库

## JVM

### JVM了解吗？

它的主要作用包括：

* **类加载器（ClassLoader）：** 负责加载 `.class` 成字节码
* **运行时数据区**：JVM 在执行程序时使用的内存区域
* **执行引擎：** 负责执行字节码
* **垃圾回收器**

### **程序计数器的作用

### ***对象创建的过程了解吗

* **类加载检查**：JVM 会先检查对应的类是否已经被加载、解析和初始化过
* **内存的分配**：指针碰撞： 适用于规整的堆内存，通过移动指针划分已用和空闲区域。空闲列表：适用于碎片化的堆内存，维护可用内存块列表并从中分配。
* **零值初始化**：JVM 会对分配的内存空间进行初始化，将其所有字段设置为零值
* **设置对象头**：Mark Word、Klass Pointer和数组长度
* **执行构造方法**

### 类载入过程 JVM 会做什么？

### ***JVM的内存模型

线程共享的的：

**元空间（方法区）**：

* **运行时常量池**：类的常量 + 符号引用 
* **类信息、常量、静态变量等数据。**

**Java 堆**：存放对象实例。

----

线程私有的：

**虚拟机栈**：局部变量、方法返回地址

**程序计数器**：存储当前线程正在执行的 Java 方法的 JVM 指令地址

**本地方法栈**：与 Java 虚拟机栈类似，主要为虚拟机使用到的 Native 方法服务。

----

**本地内存**

### ***内存泄漏和内存溢出的理解

**内存泄漏**

* 静态集合类如 `HashMap`、`ArrayList`，往里面不断添加对象，导致垃圾回收无法回收
* 线程持有外部引用

### ***OOM类型和原因-OutOfMemoryError

**堆内存溢出** **-Java Heap Space**

* **对象过多**
* **内存泄漏**（对象长期持有，无法被 GC 释放）
* **创建过大的对象**

**Metaspace 溢出** **-Metaspace OOM**

* **过多动态生成的类**（如**大量代理类、反射**，这是因为**动态生成的类都存在元空间**）
* **应用依赖的第三方库过多**

### StackOverflowError 

* **递归深度过深**，导致 **栈帧爆满**

### ***Error和exception

**Error**

* OOM
* StackOverflowError
* NoClassDefFoundError。 JVM在运行时找不到某个类定义。这通常是因为在编译时类存在，但在运行时类路径（classpath）中缺失。

**Checked Exception**和**RuntimeException**

**Checked Exception**

* FileNotFoundException

* IOException，读写文件失败
* InterruptedException,线程被中断

**RuntimeException**

* NullPointerException
* ArrayIndexOutOfBoundsException
* StringIndexOutOfBoundsException
* ArithmeticException 除0异常
* ClassCastException 类型转换异

### *运行时常量池，字符串常量池，常量池之间的关系

**运行时常量池**在**元空间（方法区）**中，其中包含字符串常量池（StringTable），而**常量池是一张表**。

### ***类加载器有哪些

### ***类加载过程

* **加载**：通过 **类的全类名** 找到 `.class` 文件，并将字节码转换为 **方法区中 **类的运行时的数据结构（c++实现的instanceKlass 描述 java 类），在堆中生成`Class` 对象。比如说可以通过对.Class对象访问到这个Klass，实例对象则访问这个Klass则是通过类对象中转访问。

* **验证**：确保字节码文件的正确性，检查字节码文件格式，字节码内容，符号引用，元数据

* **准备**： 为**类的静态变量** 分配内存，并赋初始值，它通常是存在类对象中的。

* **解析**：**符号引用**（类、方法）替换为 **直接引用**（地址）

* **初始化**：执行类的静态代码块，给静态变量赋值，只有在**真正使用**该类时才触发，如：
  - `new` 关键字创建对象
  - 访问静态变量/调用静态方法
  - 反射调用 `Class.forName("com.example.MyClass")`

###  ***双亲委派模型的作用

* 保护 **Java 核心 API**，防止篡改
* 防止类的重复加载，确保**类的唯一性**

### 如果有个大对象一般是在哪个区域？

### 四大引用

### 字符串变量的拼接和字符串常量的拼接

s1 + s2的本质是StringBuilder的append然后toString(),会new一个新的字符串对象。而“a” + “b” = “ab”，”ab“对象本质上是存在字符串常量池中

### ***Gc Root是哪些

* 调用方法中的局部变量、类中的static变量引用某些堆中的变量、常量引用的对象

###  ***垃圾回收算法有？

### 垃圾回收器有哪些？

* **ParNew GC** 和**CMS**
* **Serial GC 和 Serial Old GC**:它在进行垃圾回收时，会暂停所有用户线程。
* **G1**

### ？引用类型有哪些？有什么区别

### **复制算法和标记整理算法的区别

复制算法主要是用于新生代，**新生代对象生命周期短**，大部分对象会被回收，只有少量对象需要复制，成本较低。

 **标记-整理算法****适用于老年代（Old Generation）**，因为老年代对象存活时间长，**复制算法的成本太高**。

### **为什么要分新生代和老年代

### ***什么时候会发生STW，圾回收过程中为什么要有stop the world?

* 根对象的可达性分析
* 对象移动和内存整理

### ***minorGC、majorGC、fullGC？

### ***垃圾回收器 CMS 和 G1

**CMS收集老年代**（并发）-标记清除 ，最小化停顿时间为目标的垃圾收集器

* **初始标记**：先将Gc root关联的**第一个对象标记**，**STW**
* **并发标记**：不会STW，**顺着GC root继续标记整个堆内存**。
* **重新标记**：因为用户线程在修改， 前面的**标记可能有错误**（为了解决浮动垃圾和对象消失（一开始是垃圾，后来也被引用了，相当于正在用的对象被回收）），所以SWT重新标记
* **并发清理**：不会STW
* **Full GC**：年轻代晋升失败老年代没有连续内存，只能full gc整理老年代 ；直接在老年代分配对象（尤其是大对象）时，由于内存碎片导致空间不足发生Full GC

**G1收集老年代和新生代**

**分区Region**，将整个Java推分成大小相同的独立Region块， 一个Region有可能属于Eden、survivor或者Old区。

* **MaxGCPauseMillis**，最大停顿时间目标
* **新生代收集**：当Eden区满时触发，扫描整个年轻代，把**Eden或者survivor**的幸存对象**拷贝**到幸存区或者 Old Region，会发生**STW**
* **并发标记周期**： 当整个堆内存使用率达到一定阈值（45%），识别整个堆中（主要是 Old Region）的存活对象，为后续的 Mixed GC 提供哪些 Old Region 最值得回收（即垃圾最多）的信息。
  * **初始标记**，标记 GC Roots 直接可达的对象，**会STW**
  * **整个堆中进行并发标记**，遍历整个堆的对象，**不会STW**
  * **重新标记**：修正错误，**STW**
  * **清理**，清理**没有存活对象**的old region，统计每个 Old Region 中存活对象的比例，为混合收集做准备。**会STW**
* **混合收集（新生代，幸存区，老年代一起收集）**：并发标记周期成功完成后，G1 就知道哪些 Old Region 含有最多的垃圾，可能会触发一次混合收集。同时回收**全部年轻代**和部分**回收价值高的老年代**。会**STW**
* **Full GC**

**区别**

* 标记-清除和复制
* CMS容易产生内存碎片，依赖 Full GC 整理内存碎片，容易产生浮动垃圾
* 老年代，整个堆内存

### *跨代引用的问题

remember set

### G1 gemin 2.5pro 回答

G1 是一款面向服务端应用、主要针对大内存（通常指 6GB 以上）和需要可预测暂停时间场景的垃圾回收器。它与之前的分代回收器（如 CMS、Parallel Scavenge/Old）最大的不同在于其**堆内存布局**和**回收策略**。

**1. G1 的堆内存结构：基于 Region**

- **分区 (Region):** G1 不再将堆物理上划分为连续的年轻代和老年代。它将整个 Java 堆划分为多个大小相等（通常为 1MB 到 32MB 之间，启动时计算确定）的独立区域 (Region)。
- **角色动态分配:** 每个 Region 在某个时刻可能扮演 Eden、Survivor 或 Old Generation 的角色。还有一种特殊的 Humongous Region，用于存储大对象（通常超过 Region 大小一半的对象会直接分配在 Humongous Region，可能跨越多个连续 Region）。
- **Remembered Set (RSet):** 为了解决跨 Region 引用的问题（例如，一个 Old Region 中的对象引用了 Eden Region 中的对象），每个 Region 都有一个关联的 Remembered Set。RSet 记录了 *其他* Region 指向 *当前* Region 的引用信息（具体来说，是记录了引用来源的 Card）。这使得 G1 在回收某个 Region 时，不需要扫描整个堆来查找外部引用，只需查看其 RSet 即可，大大减少了 Young GC 和 Mixed GC 的扫描范围。

**2. G1 的垃圾回收流程**

G1 的回收过程主要涉及以下几种类型的 GC 活动，它们穿插进行：

- **Young GC (年轻代回收 / Evacuation Pause):**

  - **触发时机:** 当 Eden 区满时触发。

  - 过程:

     这是一个 Stop-The-World (STW) 的暂停。G1 会选定所有当前的 Eden Region 和 Survivor Region 组成 

    Collection Set (CSet)

    。然后，扫描 CSet 中的对象：

    - 存活的对象会被复制（Evacuate）到新的 Survivor Region 或者 Old Region（如果对象年龄达到阈值或 Survivor 区空间不足）。
    - 死亡的对象占用的空间被回收。
    - 在这个过程中，会更新相关 Region 的 RSet（因为对象移动了位置，引用关系可能改变）。

  - **特点:** 只回收年轻代区域，速度较快，暂停时间相对容易控制。G1 会根据用户设定的目标暂停时间 ( `-XX:MaxGCPauseMillis` ) 和历史数据来动态调整年轻代 Region 的数量，以尽量满足暂停时间目标。

- **Concurrent Marking Cycle (并发标记周期):**

  - **目标:** 识别整个堆中（主要是 Old Region）的存活对象，为后续的 Mixed GC 提供哪些 Old Region 最值得回收（即垃圾最多）的信息。
  - **触发时机:** 当整个堆内存使用率达到一定阈值时（由 `-XX:InitiatingHeapOccupancyPercent` 控制，默认 45%）会启动。它不是一次性完成的，而是穿插在 Young GC 之间并发执行。
  - 主要阶段:
    1. **Initial Mark (初始标记):** 标记 GC Roots 直接可达的对象。这个阶段需要 STW，但它通常** piggyback（搭便车）** 在一次 Young GC 上完成，所以增加的暂停时间很短。
    2. **Root Region Scanning (根区域扫描):** 扫描在 Initial Mark 暂停中标记的 Survivor Region 对 Old Region 的引用。此阶段与应用程序并发运行，不需要 STW。
    3. **Concurrent Marking (并发标记):** 从 GC Roots 开始，遍历整个堆的对象图，查找所有存活对象。这是并发标记的核心阶段，与应用程序并发执行，耗时可能较长，但不会暂停应用。G1 使用 **SATB (Snapshot-At-The-Beginning)** 算法来处理并发标记期间对象引用关系的变化。
    4. **Remark (重新标记):** 处理在并发标记阶段结束后，因应用程序运行而产生的少量引用变化（主要是处理 SATB 记录的日志）。这是一个 STW 阶段，但通常比 CMS 的 Remark 要快。
    5. Cleanup (清理):
       - 识别出完全没有存活对象的 Old Region，并立即回收这些 Region 的空间（这个过程部分 STW，部分并发）。
       - 统计每个 Old Region 中存活对象的比例（Liveness），用于后续 Mixed GC 筛选 CSet。
       - 重置 RSet 相关信息。

- **Mixed GC (混合回收 / Evacuation Pause):**

  - **触发时机:** 在并发标记周期成功完成后，G1 就知道哪些 Old Region 含有最多的垃圾。当后续触发 Young GC 时，G1 *可能* 会决定执行一次 Mixed GC。
  - **过程:** 这也是一个 STW 的暂停。它的 CSet 不仅包含**所有**的 Young Region (Eden + Survivor)，还会根据用户设定的暂停时间目标和各个 Old Region 的回收价值（垃圾比例），选择**部分**回收收益高的 Old Region 加入 CSet。然后，像 Young GC 一样，将 CSet 中所有 Region 的存活对象复制到新的 Region（可能是 Survivor 或 Old）。
  - **特点:** 同时回收年轻代和部分老年代。这是 G1 "Garbage-First" 名字的由来，因为它优先回收垃圾最多的区域。G1 会执行多次 Mixed GC 来逐步回收老年代的垃圾，而不是一次性回收所有老年代（避免长时间暂停）。Mixed GC 的次数由 `-XX:G1MixedGCCountTarget` 等参数影响。

- **Full GC (完全回收):**

  - 触发时机:

     G1 会尽量避免 Full GC。但在某些极端情况下，例如：

    - 并发模式失败（如并发标记过程中 OOM）。
    - 提升失败（Evacuation Failure）：在 Young GC 或 Mixed GC 期间，需要将对象复制到 Survivor 或 Old 区，但找不到足够的连续空间。
    - 分配 Humongous 对象时空间不足。
    - 显式调用 `System.gc()` (除非配置了 `-XX:+ExplicitGCInvokesConcurrent`)。

  - **过程:** G1 的 Full GC 是单线程的、STW 的，并且会对整个堆进行整理（Compaction）。这会导致非常长的暂停时间，是 G1 性能优化的主要规避目标。如果频繁发生 Full GC，通常意味着需要调整 G1 的配置或增加堆内存。

**总结 G1 流程特点:**

1. **基于 Region:** 内存管理更灵活，方便进行局部回收。
2. **可预测的暂停时间:** 通过选择回收部分 Region (CSet) 和动态调整 Young Region 数量，尝试满足用户设定的 `-XX:MaxGCPauseMillis` 目标。
3. **并发标记:** 使用并发标记周期来识别老年代垃圾，减少 STW 时间。
4. **Garbage-First 策略:** 在 Mixed GC 中优先回收垃圾最多的 Old Region，提高回收效率。
5. **空间整理:** 回收过程是基于复制（Evacuation）的，天然地避免了内存碎片问题（除了 Full GC）。

理解 G1 的关键在于理解 Region 的概念、RSet 的作用以及 Young GC、Concurrent Marking Cycle 和 Mixed GC 这几个核心阶段是如何协同工作的。

### ***常用的jdk版本

### ？？？java的内存分配和回收过程

### ThreadLocal原理和内存泄漏原因

每个Thread实例维护一个map，map中的key是threadlocal实例，value是你往对应threadlocal存的值，而thread对threadmap是强引用，map对value是强引用，而tomcat的线程是不会被销毁的，那么value永远得不到回收。

### ThreadLocal应用场景

## RabbitMQ

### RabbitMQ 如何保证消息不丢失？

* 第一个是**消息从生产者到 RabbitMQ** 的阶段：有消息确认机制，mq收到之后会发送ack。如果消息未能成功写入，RabbitMQ 会返回一个 NACK，生产者则重新发消息。
* 第二个是**消息在 RabbitMQ 中**的阶段：MQ可以设置一个持久化模式，这个持久化包括三个方面，交换机持久化，队列持久化，消息持久化。设置了这三个持久化之后，队列会先把消息先读取到内存，然后异步写入到磁盘。
* 第三个是**消息从 RabbitMQ 到消费者**的阶段：基础的消费者确认机制，消费者成功消费，向mq发送ack。消费者处理失败，发送nack，mq重新发送消息。-------------然后就是消息重试策略和死信队列机制，出现异常时先本地重试，重试失败之后在发送给mq，mq重新发送给消费者，对于多次重新发送的消息，送到死信队列中可以排查故障。

### RabbitMQ的作用？

* 业务之间解耦合。
* 无需等待，性能比较好
* 高可靠性，支持消息持久化、消息确认机制和事务机制，确保消息不会丢失。

### 什么样的消息会进入死信队列

* TTL 到期后消息未被消费，就会进入死信队列
* **队列长度** 超过最大限制（`x-max-length`），**最早的消息** 会被**丢弃到死信队列**。
* 消费者**主动拒绝**消息（reject），且不让 RabbitMQ 重新投递。

### 消息重复消费怎么解决

## Linux

select、epoll和poll的区别

### 讲讲你比较常用的 Linux 指令

### linux如何查看java进程，服务名称为test1的，并且把进程杀掉

`ps -ef | grep java | grep test1 | awk '{print $2}' | xargs kill -9`

- `ps -ef`：列出所有进程
- `grep java`：筛选出包含 `java` 的进程
- `grep test1`：进一步筛选包含 `test1` 的进程
- `awk '{print $2}'`：提取进程 ID（PID）
- `xargs kill -9`：`xargs` 作用是 **读取PID），然后作为参数传递给 `kill -9`**。

### Linux输出一个文件的第10行 

### Linux查看日志筛选某个关键字 并定位到行

`grep -n "ERROR" /var/log/syslog`

🔹 `-n`：显示匹配的行号
 🔹 `ERROR`：要搜索的关键字
 🔹 `/var/log/syslog`：日志文件

### linux查看CPU占用性能 如果要筛选java程序的占用呢 

`top -b | grep java`  

## 计算机网络

NIO（非阻塞IO）,BIO（阻塞IO）,AIO

### get和post区别

* get请求资源，post发送资源，一个有请求体一个没有
* get天然幂等，post不是幂等的
* get结果可以被缓存，post一般不缓存

### ***应用层有哪些协议

* HTTP、HTTPS：网页浏览
* FTP：文件传输
* SMTP：邮件传输
* DNS：解析域名的ip地址
* CDN：

### ***HTTP 状态码

* HTTP 状态码分为五个类别，分别以 1、2、3、4、5 开头，代表信息性、成功、重定向、客户端错误和服务器错误。

* 1xx 状态码表示请求已被接收，客户端可以继续请求。比如：100 Continue。在 2xx 成功状态码中，最常见的是 **200 OK**，表示请求成功并返回数据；**201 Created** 表示服务器成功创建了新的资源。在 3xx 重定向中，**301 Moved Permanently 用于永久重定向**，**302 Found** 用于临时重定向。**4xx** 是客户端错误，比如 400 Bad Request 表示请求格式错误，**401 Unauthorized 表示未授权**，**403 Forbidden 表示禁止访问**，最常见的 **404 Not Found** 表示资源不存在。5xx 是服务器错误，比如 500 Internal Server Error 表示服务器内部错误，503 Service Unavailable 表示服务暂时不可用。

### HTTP的长连接是什么？

### HTTP为什么不安全？

### ***tcp/ip网络模型

* **应用层**:提供用户直接使用的网络服务，如网页浏览、文件传输等。（HTTP（网页）、FTP（文件传输）、DNS（域名解析）

* **传输层**：端到端的数据传输服务。TCP 协议提供可靠的、面向连接的服务，而 UDP 协议提供不可靠的、无连接的服务。
* **网络层**：主要处理 IP 协议，负责数据包的路由和寻址，实现不同网络之间的数据包转发。
* **网络接口层**：负责在同一局域网内传输数据，比如网络包的封帧、 MAC 寻址。

### ？解释 DNS 的作用和工作原理。

### tcp的滑动窗口和拥塞控制

### 哪些应用是udp，哪些用是tcp

* **TCP:**HTTP / HTTPS,FTP（文件传输协议）,SMTP（简单邮件传输协议）
* **UDP**：DNS（域名系统），实时视频和语音传输，在线游戏

### ？进程通信的方式,线程之间的通信方式

### ？HTTP 状态码有哪些？

### HTTP1.1 -> HTTP2.0 -> HTTP3.0

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- **长连接**：使用长连接的方式改善了 **HTTP/1.0 短连接**造成的性能开销，不用每次请求都tcp**握手挥手**。
- **管道网络传输**：（HTTP1.0 :完全串行执行，后一个请求必须在前一个响应之后发送。）请求可以并行发出，但是响应必须串行返回。
- 但1.1仍然有其缺点**-队头阻塞**，虽然一次可以发送多个请求，但是服务端响应的顺序只能根据请求顺序响应，如果第一个请求的处理非常耗时，后续的响应即使已经准备好也无法发送。

HTTP/2 协议是基于 HTTPS 的

* **头部压缩** ：如果你同时发出多个请求，他们的头是一样的或是相似的，协议会帮你**消除重复的部分**。
* HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**.
* **多路复用**:HTTP/2 允许多个请求和响应在同一个 TCP 连接上**并发**地进行, 客户端可以同时发送多个请求的帧，服务器也可以同时发送多个响应的帧，而**不必按照先进先出的顺序**。接收端会根据帧中的流 ID 将属于同一个请求或响应的帧重新组装成完整的 HTTP 报文。

假设一个网页需要加载三个资源：HTML 文件 (Stream 1)、CSS 文件 (Stream 2) 和一张图片 (Stream 3)。

- **HTTP/1.1:** 浏览器通常会发起多个串行请求（受浏览器对同一域名并发连接数的限制）。如果 HTML 文件的响应很大或者服务器处理较慢，CSS 和图片即使服务器已经准备好也必须等待 HTML 文件完全下载完毕后才能开始传输（在同一个连接内）。
- **HTTP/2:** 浏览器会为这三个资源创建三个独立的流 (Stream 1, 2, 3)，并通过同一个 TCP 连接并发地发送请求帧。服务器可以并行地处理这三个请求，并将它们的响应分解成帧，并带有相应的流 ID，然后交错地在同一个 TCP 连接上发送这些帧。浏览器接收到这些帧后，会根据流 ID 将它们重新组装成完整的 HTML、CSS 和图片，而不会因为其中一个资源的传输缓慢而阻塞其他资源的传输。

* **服务器主动推送资源**：客户端在访问 HTML 时，服务器可以直接主动推送客户端可能需要的资源。

### HTTP和HTTPS的区别

### https的加密过程 

* 服务器发送包含其**公钥**的证书给客户端。

  客户端用 CA 公钥验证证书，获取并信任服务器的公钥。

  客户端**自己生成**一个随机秘密（**预主密钥 PMS**）。

  客户端用**服务器的公钥**加密这个 PMS。

  客户端将加密后的 PMS 发送给服务器。

  服务器用**自己的私钥**解密，得到 PMS。

### HTTPS加密,对称加密和非对称,为什么不只用其中一个呢?

https如何实现可靠传输

* 加密 
* **CA 签名验证:** 客户端会使用预装的 CA 的公钥来验证服务器证书上的签名，以确保证书是由可信的 CA 颁发的，没有被篡改。

### 什么是 TCP ？

### **TCP 和 UDP 区别：**

- TCP 传输数据前先要建立连接。UDP 是不需要，即刻传输数据。
- TCP 是一对一的两点服务。UDP 支持一对一、一对多、多对多的交互通信
- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有。
- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到。UDP 不保证可靠交付数据。

### ？TCP的数据校验方式

### ？有哪些非对称加密算法， 有哪些对称加密算法

### ***为什么是三次握手

- 假设只有两次握手。客户端发送一个 SYN 包，服务器收到后回复 SYN+ACK，连接就建立了。如果一个延迟的、失效的 SYN 包（由于网络拥塞等原因滞留）到达服务器，服务器会认为这是一个新的连接请求，并发送 SYN+ACK，然后等待客户端发送数据。这就浪费了客户端的资源。**三次握手中的 ACK 就是为了确认服务器收到了客户端的 SYN，从而避免服务器为过时的 SYN 包建立连接。**
-  如果服务器发送的 SYN-ACK 包在网络中丢失，客户端并不知道连接已经建立成功。客户端可能会一直等待服务器的确认，而服务器却在等待客户端发送数据。这会导致客户端认为连接失败，而服务器却处于等待数据的状态，造成**连接状态的不一致**。

###  ？HTTP协议流程

### TCP 四次挥手过程是怎样的？

### 为什么要等待2MSL？

如果服务端没有接收到客户端最后的ack，就会重发fin报文，这个时候为了正确关闭服务端的连接，所以客户端要等一下可能还存在的fin报文，2MSL是允许报文丢一次的时间。

### 为什么挥手要四次

### ？TCP关闭连接后操作系统需要释放哪些资源？

### ***滑动窗口、流量控制、拥塞控制

* **TCP 的流量控制** 是通过 **滑动窗口机制** 来实现的，接收方通过 TCP 头部的 **窗口大小字段**告知发送方自己剩余的缓冲空间，发送方根据这个信息调整发送速率，以避免接收方的缓冲区溢出。

* 发送方的滑动窗口大小等于：已发送未确认+未发送可发送的大小。

* 拥塞控制：拥塞窗口（cwnd）是在发送端定义的，一旦出现丢包，拥塞窗口就会减小，发送端的最大发送范围是拥塞窗口和滑动窗口中较小的一个
* **慢启动（Slow Start）**：
  - 初始 `cwnd` 小，每收到1个 ACK，**cwnd 的大小就会加 1，实现 指数增长**，直到达到 慢启动门限（ssthresh）
  - 拥塞避免算法：**每当收到一个 ACK 时，cwnd 增加 1/cwnd**，线性增加
  -  拥塞发生，启用快速重传，`cwnd = cwnd/2` ，也就是设置为原来的一半; `ssthresh = cwnd`;
  -  快速恢复

### ***TCP实现可靠传输的原理

* 三次握手
* 数据分块与序号标识
* 确认应答（ACK）与超时重传
* 流量控制
* 拥塞控制

### UDP如何实现可靠连接?

### 粘包问题知道吗?TCP和UDP都会有粘包问题吗?

#### 方法一：长度作为消息头 (Length-Prefixed Framing) - **业界标准方案**

这是绝大多数需要高性能、高可靠性的自定义网络协议（如游戏、金融、即时通讯、RPC框架）的首选方案。

**协议设计：**

每个要发送的数据包，在应用层被构造成两个部分：
[固定长度的头部] + [可变长度的消息体]

- **头部 (Header)**：通常是 2 个或 4 个字节的整数，用来明确表示**后面紧跟着的消息体的长度**。
- **消息体 (Body)**：这才是真正要传输的业务数据，比如序列化后的 JSON、Protobuf 数据等。

### OSI七层模型

* **应用层**：直接向用户应用程序提供网络服务。定义了用户程序发送请求的规则
* **表示层**：数据进行加密和解密的。
* **会话层**：会话层（第五层）主要负责管理**应用程序之间**的通信会话，或者说是建立、管理和终止**进程间的对话**。还要对话控制，全双工，半双工
* **传输层**：这一层主要是建立端到端的连接，要建立两个正确的端口号的连接，tcp
* **网络层**：主要是定义一个在整个互联网寻址的规则，ip寻址。
* **网络接口层**：主要解决在局域网怎么寻址路由封包的问题，mac地址来寻址
* **物理层**：主要解决0和1怎么转化为信号在物理链路上传输的问题

### arp协议

好的，我们来详细讲解一下ARP协议。

#### ARP协议（地址解析协议）是什么？

ARP（Address Resolution Protocol），即地址解析协议，是计算机网络中一个至关重要的底层协议。它的核心作用是在一个局域网（LAN）内，将一个已知的IP地址解析（转换）成对应的物理地址，也就是MAC地址（硬件地址）。

简单来说，当你的电脑想和局域网里的另一台电脑通信时，它只知道对方的IP地址，但数据在局域网内最终是依靠MAC地址来找到目标设备的。ARP协议就是那个负责“问路”的协议，它会广播一个消息：“嘿，IP地址是xxx.xxx.xxx.xxx的设备，你的MAC地址是什么？”然后对应的设备就会回应：“我的MAC地址是xx:xx:xx:xx:xx:xx”。

#### 为什么需要ARP协议？

这要从网络分层说起：

1.  **网络层（IP层）**：负责在整个互联网范围内根据IP地址找到目标主机所在的网络。它处理的是“去往哪个城市”的问题。
2.  **数据链路层（以太网层）**：负责在同一个局域网（比如同一个Wi-Fi下、同一个交换机连接的所有设备）内，根据MAC地址精确地找到目标设备。它处理的是“到了这个城市后，具体是哪条街道哪个门牌号”的问题。

当一台主机要发送数据给另一台主机时，数据包会从上到下封装。在数据链路层封装时，必须知道目标主机的MAC地址才能将数据帧准确地发送出去。ARP协议就解决了这个从IP地址到MAC地址的映射问题。

#### ARP协议的工作原理

ARP的工作过程可以分为两个核心部分：**ARP请求**和**ARP响应**，并利用**ARP缓存**来提高效率。

**场景**：假设主机A（IP: 192.168.1.10）要向主机B（IP: 192.168.1.20）发送数据，但A只知道B的IP地址。

**工作步骤如下**：

1.  **检查ARP缓存**：
    *   主机A首先会检查自己的**ARP缓存表**。这个表存放了近期查询过的IP地址与MAC地址的对应关系。
    *   如果缓存中存在192.168.1.20对应的MAC地址，主机A就会直接使用这个MAC地址来封装数据帧并发送，过程结束。
    *   如果缓存中没有找到，则进入下一步。

2.  **发送ARP请求**：
    *   主机A会构建一个**ARP请求（ARP Request）**报文。
    *   这个报文的核心内容是：“我的IP是192.168.1.10，我的MAC是[A的MAC地址]，我想知道IP地址为192.168.1.20的设备的MAC地址是什么？”
    *   这个请求报文会以**广播**的形式在局域网内发送。这意味着，局域网内的所有设备（包括路由器、交换机、其他电脑等）都会收到这个请求。

3.  **处理ARP请求**：
    *   局域网内的每一台设备收到这个广播请求后，都会检查其中的目标IP地址（192.168.1.20）。
    *   如果设备的IP地址不是192.168.1.20，它就会忽略这个请求。
    *   只有主机B发现目标IP地址是自己的，它才会处理这个请求。

4.  **发送ARP响应**：
    *   主机B在收到请求后，会首先将主机A的IP和MAC地址对（192.168.1.10 -> [A的MAC地址]）存入自己的ARP缓存表中，以便将来直接与A通信。
    *   然后，主机B会构建一个**ARP响应（ARP Reply）**报文。
    *   这个报文的内容是：“我就是IP地址为192.168.1.20的设备，我的MAC地址是[B的MAC地址]。”
    *   这个响应报文会以**单播**的形式直接发送给主机A（因为请求中已经包含了A的MAC地址）。

5.  **更新ARP缓存并发送数据**：
    *   主机A收到主机B的ARP响应后，就会将主机B的IP和MAC地址对（192.168.1.20 -> [B的MAC地址]）存入自己的ARP缓存表中。
    *   现在主机A已经知道了目标MAC地址，于是它就可以封装数据帧，将数据成功发送给主机B了。







## 操作系统

### 进程调度算法有哪些？

### java里面的线程和操作系统的线程一样吗

### 进程切换和线程切换的区别？

* 进程切换：

### ***进程通信和线程通信区别是什么

### ***如何让两个不同进程的线程进行通信

### ***进程进行通信方式

* **共享内存和信号量**
* **管道**：通信效率相对较低，涉及到内核缓冲区的数据拷贝。顺序访问，不支持随机读取。
* **消息队列**：队列的长度和消息的大小可能受到系统限制。
* **Socket**：可以用于不同机器上的进程通过网络进行通信.从本质上讲，Socket 可以看作是**应用程序和网络协议栈之间的一个接口**。它隐藏了底层复杂的网络协议细节（如 TCP/IP 协议族），为应用程序提供了一组简单的 API（例如 `send`、`receive`、`connect`、`accept` 等），使得开发者可以方便地进行网络数据传输，而无需深入了解网络协议的实现。、

## 数据结构

### 栈的使用场景

* 括号匹配检查
* 函数累计调用里面的栈帧

### 堆

* 出堆：将堆顶元素弹出，然后将数组的最后一个元素（即最右侧的叶子节点）放到堆顶，尝试把他下沉
* 入堆：把元素放到数组最后一个位置，即最右侧的叶子节点，尝试上浮
* 一般用数组实现堆
* 出堆，入堆，删除都是logn的时间复杂度，然后建堆时间复杂度

### 堆的使用场景

* 优先级队列 :操作系统的进程调度、定时任务的执行、异步消息队列中需要优先处理的消息

### 堆求解topk问题：

- 先从n中取出前k个元素，组成一个小顶堆，此时堆顶元素是最小的，我们从K+1个元素开始，和堆顶元素进行比较，如果比堆顶元素小，那么不做处理，继续下一个；如果比堆顶元素大，那么把堆顶元素删除，并插入k+1这个元素；等到n个元素全部遍历完，那么小顶堆中的k个元素就是Top-k数据了；
- 对于外部不断添加进来的数据其实思路是一样的，把它当成数据源，不断地和堆顶元素比较，重复上面的步骤操作即可。

时间主要耗费在一开始k个元素的初始建堆O(logk)上，还有删除堆顶元素和插入新元素时的堆化O(logk)上；所以，总的时间复杂度应该为O(nlogk)，比使用排序来获取Top-k的O(nlogn)还是要高效的。

### 红黑树

## 场景题

### 场景题，对1个亿数据进行排序，内存只有10M 怎么排序最好

## GIT

### git reset  --hard||mixed||softed commitId

--hard 所有暂存区或者工作区的修改全部没有

--mixed 所有改动代码全在工作区

--softed 回滚到暂存区

### git merge和git rebase

### git clone -b 分支名字  

## AI面

### Left join ,right join 和inner join的区别

### String对象为什么是不可变的，如何理解。

###  tcp，http,ftp分别属于那一层。

* **TCP 属于传输层，负责数据传输。**

* **HTTP 和 FTP 都是应用层协议，分别用于网页浏览和文件传输。**

* **HTTP 和 FTP 都依赖于 TCP 进行可靠的传输。**

### 消息重复消费怎么解决

### linux怎么创建、复制、移动、删除文件夹

* mkdir mydir
* cp -r mydir backup_mydir
* mv mydir newdir
* rm -r mydir

### 为社交媒体应用设计一个热门话题功能，如何统计和展示热门话题。

### Linux中的权限控制，通过什么命令修改文件权限





## leader面

### 你为什么选择客户端开发这个方向,对客户端有什么了解

### 你对实习的期望是什么？希望在百度收获什么？

### 你未来的职业规划是怎样的

### 用三到五个词形容一下你自己，并解释为什么。

### 你为什么选择百度？对百度有什么了解？

### 你是如何学习新技术的？可以举个例子吗？

### 有没有读过哪些优秀的技术博客、书籍，或者关注了哪些技术大牛

### 缺点

### 这次的自我介绍可以更侧重于你的项目经验、技术热情、解决问题的能力以及为什么想做客户端开发。

### 项目经验与技术思考

### 项目中遇到的最大困难是什么？你是如何克服的

### 如果让你重新做这个项目，你会做哪些改进?最大的收获是什么

### 你对百度的客户端产品有什么看法或建议吗？

### 你在项目中是如何进行团队协作的？如果遇到意见不合的情况怎么办？

### 你认为一个优秀的客户端产品应该具备哪些特质

### 对于客户端的性能优化，你有什么思路？

### 分片上传和断点续传怎么实现的

分片上传和断点续传是靠前后端协同来实现的，这个功能涉及两个接口，一个接口是预上传接口（预上传接口主要是为了生成和视频对应的Redis对象），一个是正式上传接口。当选择了一个视频之后，前端会立马根据文件大小分片，每个分片是1m ，这个时候就会去访问后端的预上传接口，把文件名和总共的分片大小两个参数传给后端的预上传接口，这个接口会生成一个跟这个视频唯一对应的uuid，然后在redis中生成一个上传对象，上传对象主要存了几个字段，唯一的uuid，文件名，视频总共的分片数，文件保存路径，当前上传到哪一个的分片的分片索引。这个接口访问完了然后会返给前端一个唯一的视频id。然后就会访问正式上传的接口，这个接口的参数主要有，刚才给前端的唯一id，文件， 当前上传的分片文件索引，然后每上传完一个文件，就会更新这个redis对象刚才说过的当前上传索引。这样就实现了分片上传，然后断点续传就是说，你带着这个uploadid去访问上传接口，就根据这个redis对象可以知道现在该传哪个分片了，比如断网了也只会丢掉一个分片大小的文件。

### 自我介绍

您好面试官，我是周佳。

 我目前是一名计算机技术专业的研二学生，我已经完成了毕业要求，可以实习6个月以上

我的项目经验在后端这块。因此对Java、多线程编程、JVM原理这些比较了解，synchronized、volatile、ConcurrentHashMap、以及 CAS、线程池这些都熟悉。

 在研究生阶段，我的研究方向主要是音频分类和深度学习，在sci一区tnnls上发表过一篇论文。然后在研究生阶段，我还获得过蓝桥杯的一些奖项。

我知道移动端开发的技术栈和后端有所不同，但对java比较熟悉，学习移动端会比较快。

我非常希望能够加入团队，也很感谢这次面试机会。



## Easylive

如果让你重新做这个项目，你会做哪些改进

 * Java 技术理解 (与客户端结合)：
   * 虽然不问安卓，但可能会问Java在客户端开发中的普遍应用。如果百度有非安卓的Java客户端产品线（例如桌面应用，或者某些内部工具），可能会涉及。如果完全没有，可能会考察你的知识迁移能力。
   * “你认为Java语言在客户端开发（广义的客户端，不局限于手机端）有哪些优势和劣势？”
   * “在客户端开发中，网络请求和数据处理是常见的，你在这方面有什么经验或者理解？” (Java的HTTP库、JSON解析等)
 * 解决问题的能力：
   * “描述一个你独立分析并解决复杂技术问题的经历。”
   * “当遇到一个你完全不懂的技术难题时，你会采取哪些步骤去解决？”
 * 沟通与团队协作：
   * “你如何理解团队合作？在一个团队中，你希望扮演什么样的角色？”
   * “如果你的想法和团队其他成员或者Leader不一致，你会怎么做？”
   * “如何有效地进行跨团队沟通？”
 * 抗压能力与主动性：
   * “如果项目deadline很紧张，任务量又很大，你会如何应对？”
   * “你是否有过主动承担责任并推动事情解决的经历？请举例。”
   * “实习期间如果遇到比较枯燥或者重复性的工作，你会如何调整心态？”
 * 对业务的思考 (可能会有)：
   * “你对百度（或者具体某个产品线，如果知道的话）的客户端产品有什么看法或建议吗？” (展现你的思考和用户视角)
   * “你认为一个优秀的客户端产品应该具备哪些特质？”
 * “作为实习生，加入团队后主要会参与到哪些类型的项目中？对我有什么样的培养计划和期望？”
 * “团队的技术氛围如何？是否有定期的技术分享和学习机会？”
 * “您认为做好这份实习工作，最重要的能力是什么？”
 * “客户端团队未来1-2年的发展重点和挑战是什么？”
    针对Java选手的特别提醒：
 * 突出Java基础的扎实性： 即使是客户端，扎实的Java基础（数据结构、算法、并发、JVM、网络编程等）也是非常重要的。Leader可能会通过一些开放性问题来考察你的基础掌握程度。
 * 展现学习和迁移能力： 如果你之前的项目经验并非直接的客户端开发，要强调你快速学习新技术的能力，以及将已有Java经验迁移到新领域的能力。
 * 思考Java与客户端的结合点： 即使不是Android，也可以思考Java在大型客户端应用中的架构设计、模块化、性能优化等方面的通用原则。
    准备建议：
 * 梳理项目经验： 按照STAR法则（Situation, Task, Action, Result）重新梳理你的项目，突出你的贡献和思考。
 * 模拟面试： 找同学或朋友进行模拟面试，特别是针对非技术性的问题。
 * 了解百度和岗位： 尽可能多地了解百度的企业文化、价值观，以及你所面试的部门和岗位信息。





